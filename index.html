<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>李嘉文</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="像鸟飞往你的山">
<meta property="og:type" content="website">
<meta property="og:title" content="李嘉文">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="李嘉文">
<meta property="og:description" content="像鸟飞往你的山">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李嘉文">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="李嘉文" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">李嘉文</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Jarvan</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode-daily-practice-20211209" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/09/Leetcode-daily-practice-20211209/" class="article-date">
  <time class="dt-published" datetime="2021-12-09T02:34:41.000Z" itemprop="datePublished">2021-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/09/Leetcode-daily-practice-20211209/">Leetcode-daily-practice-20211209</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="中等-剑指-Offer-31-栈的压入、弹出序列"><a href="#中等-剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="(中等)剑指 Offer 31. 栈的压入、弹出序列"></a>(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h5><p>这题思路很简单，首先模拟入栈操作，在每次入栈后，判断栈顶元素是否是目标元素。如果是则出栈，目标元素变为下一个，接着判断栈顶和目标元素，直到空栈或者栈顶不是目标元素。当所有的元素都入过栈之后，正确的出栈顺序会清空栈，所以判断最后是否栈空，即可知道是否是正确的出栈顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : pushed)&#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">            <span class="keyword">while</span>(cur &lt; popped.length &amp;&amp; popped[cur] == stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                cur ++;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h5 id="中等-剑指-Offer-32-I-从上到下打印二叉树"><a href="#中等-剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="(中等)剑指 Offer 32 - I. 从上到下打印二叉树"></a>(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h5><p>层序遍历，由于最开始节点数目不能确定，所以节点的值应首先放在List中，最后转移到int[]数组中。</p>
<h5 id="中等-剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#中等-剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="(中等)剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h5><p>这题较上一题更难，一是每层元素的值存放在一个List，二是奇偶层的顺序相反。思路是，利用队列层序遍历，额外用一个中间数据结构(LinkedList)存储每层的节点值，用已建好的遍历结果区分奇偶层，调整输出顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()&#123;&#123;offer(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=queue.size(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 奇数层，正序</span></span><br><span class="line">                <span class="keyword">if</span>(result.size() % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    list.addLast(node.val);</span><br><span class="line">                <span class="comment">// 偶数层，倒序</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.addFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免入队操作影响现在层中的元素输出，这里的for循环倒着写。还有注意的是<code>addFirst()</code>和<code>addLast()</code>是LinkedList的方法，而非List的方法。</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h5 id="中等-剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#中等-剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="(中等)剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h5><p>这题首先想到递归和分治，分治的每一部分都是后序遍历，结构是<code>[[左子树],[右子树],[根节点]]</code>，依次找到左右子树的分界，右树和根节点的分界，验证是否符合左小右大的原则。满足原则时，递归验证左子树和右子树。</p>
<ul>
<li>递归分治</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归分治</span></span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        <span class="type">return</span> <span class="variable">p</span> <span class="operator">=</span>= j &amp;&amp; recur(postorder, i, m-<span class="number">1</span>) &amp;&amp; recur(postorder, m, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2^)，每次调用recur()，时间复杂度为O(n)，最坏情况下（树退化为链表），需要调用n次。</li>
<li>空间复杂度：O(n)，最坏情况下，递归n次。</li>
</ul>
<p>当然还有更快的算法。反向遍历数组，使用单调栈依次存储右子树的根节点，如果遍历元素小于栈顶元素，这意味着遍历元素是根节点的左子树，弹出栈顶元素；如果遍历元素大于栈顶元素，这违背了左小右大的原则。</p>
<ul>
<li>单调栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=postorder.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; postorder[i] &lt; stack.peek()) root = stack.pop();</span><br><span class="line">            stack.add(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)。不是O(n^2^)，这是由于，即使在最坏情况下，每个元素只是入栈出栈一次。</li>
<li>空间复杂度：O(n)</li>
</ul>
<h5 id="中等-剑指-Offer-34-二叉树中和为某一值的路径"><a href="#中等-剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="(中等)剑指 Offer 34. 二叉树中和为某一值的路径"></a>(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h5><p>这题我首先想到了广度优先算法，使用队列作为遍历用的数据结构，另外定义<code>Map&lt;TreeNode, List&lt;Integer&gt;&gt;</code>存储已经生成的路径，<code>Map&lt;TreeNode, Integer&gt;</code>存储累加到某个节点的数值。实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Map&lt;TreeNode, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;put(root, <span class="keyword">new</span> <span class="title class_">LinkedList</span>()&#123;&#123;add(root.val);&#125;&#125;);&#125;&#125;;        </span><br><span class="line">        Map&lt;TreeNode, Integer&gt; value_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;put(root, root.val);&#125;&#125;;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()&#123;&#123;offer(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> value_map.get(node);</span><br><span class="line">            List&lt;Integer&gt; list = getList(map, node);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">                value_map.put(node.left, value+node.left.val);</span><br><span class="line">                list.add(node.left.val);</span><br><span class="line">                map.put(node.left, list);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            list = getList(map, node);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                value_map.put(node.right, value+node.right.val);</span><br><span class="line">                list.add(node.right.val);</span><br><span class="line">                map.put(node.right, list);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; value == target) result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getList</span><span class="params">(Map&lt;TreeNode, List&lt;Integer&gt;&gt; map, TreeNode node)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = map.get(node);</span><br><span class="line">        List&lt;Integer&gt; new_list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">            new_list.add(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> new_list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有使用map.get()来获取List，而是自定义了getList()，其中原因是，map.get()返回的是List的引用，而之后list.add()也是对引用操作，再之后的map.put()也是对引用操作，这会导致最后所有的元素都被放在list当中了，而并非是根节点到叶子节点的元素。当然时间复杂度O(n^2^)，空间复杂度O(n)。</p>
<p>遍历每个节点的时候，都要维护到达该节点的路径，如果最后不是所找的路径，那时间和空间就都浪费了，故可以使用map记录子结点与父节点，满足要求之后再将路径组装出来，时间复杂度和空间复杂度还是一样，但是时间和空间消耗会更小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueSum = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queueSum.offer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queueNode.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rec</span> <span class="operator">=</span> queueSum.poll() + node.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rec == target) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(node.left, node);</span><br><span class="line">                    queueNode.offer(node.left);</span><br><span class="line">                    queueSum.offer(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(node.right, node);</span><br><span class="line">                    queueNode.offer(node.right);</span><br><span class="line">                    queueSum.offer(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            node = map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(temp);</span><br><span class="line">        ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最优的方式是深度优先遍历，原因是，递归本身都需要递归栈，这样连重新组装路径都省了，只要动态的根据栈调整入队出队。时间复杂度仍是O(n^2^)，空间复杂度仍是O(n)，但更快，内存负担更小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        dfs(root, target);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.offerLast(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, target);</span><br><span class="line">        dfs(root.right, target);</span><br><span class="line">        path.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中等-剑指-Offer-35-复杂链表的复制"><a href="#中等-剑指-Offer-35-复杂链表的复制" class="headerlink" title="(中等)剑指 Offer 35. 复杂链表的复制"></a>(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h5><p>这题的难点在于，如果只有next指针，那么依次拷贝就可以的。但同时还有random指针，next指针指向下一个节点时，random指针指向的节点可能还没建立。最后找到两种思路：</p>
<ul>
<li>递归 + 哈希表（哈希表存储每一个节点的新节点的创建情况）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(head))&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">new_head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            map.put(head, new_head);</span><br><span class="line">            new_head.next = copyRandomList(head.next);</span><br><span class="line">            new_head.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<ul>
<li>三次迭代。这个方法比较巧妙，首先在原链表的每一个节点后追加一个影子节点，每个节点复制前一个节点的next和random指针，最后断开连接，返回所有的影子节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 建立影子节点</span></span><br><span class="line">        <span class="keyword">for</span>(Node node=head; node != <span class="literal">null</span>; node=node.next.next)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">new_node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">            new_node.next = node.next;</span><br><span class="line">            node.next = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 建立影子节点的random指针</span></span><br><span class="line">        <span class="keyword">for</span>(Node node=head; node != <span class="literal">null</span>; node=node.next.next)&#123;</span><br><span class="line">            node.next.random = node.random != <span class="literal">null</span> ? node.random.next : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开与原链表的连接</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">new_head</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">for</span>(Node node=head; node != <span class="literal">null</span>; node=node.next)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">new_node</span> <span class="operator">=</span> node.next;</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">            new_node.next = new_node.next != <span class="literal">null</span> ? new_node.next.next : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/09/Leetcode-daily-practice-20211209/" data-id="cl2umtqhs000e1tswfgif321b" data-title="Leetcode-daily-practice-20211209" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-daily-practice-20211208" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/08/Leetcode-daily-practice-20211208/" class="article-date">
  <time class="dt-published" datetime="2021-12-08T13:31:44.000Z" itemprop="datePublished">2021-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/08/Leetcode-daily-practice-20211208/">Leetcode-daily-practice-20211208</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">剑指 Offer 20. 表示数值的字符串</a></h5><p>这里需要引入状态的概念。首先定义全部的合法状态，接着依次遍历每个字符，由字符指导接下来的状态。如果状态转移失败，那意味着不合规则。</p>
<p>官方称之为<code>确定有限状态自动机</code>，这太抽象啦。</p>
<h5 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h5><p>对于这题，递归解法最适合。思路是，检查B是否是A的子结构（匹配B的子节点和A的子节点），匹配到了返回true，否则返回false；若不匹配，则递归检查B是否是A的左右子树的子结构。这是两个重要过程，一是匹配环节，二是递归环节。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) &amp;&amp; (check(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode A, TreeNode B)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(A.left, B.left) &amp;&amp; check(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设M、N分别是A树、B树的节点数，则</p>
<ul>
<li>时间复杂度为O(M*N)，对A树的每个节点都试图匹配B树。</li>
<li>空间复杂度为O(M)，当M&lt;&#x3D;N时，递归深度为树A的节点数，当M&gt;N时，递归或匹配全部的树A的节点。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/08/Leetcode-daily-practice-20211208/" data-id="cl2umtqhs000d1tsw16pncrn7" data-title="Leetcode-daily-practice-20211208" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-daily-practice-20211207" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/08/Leetcode-daily-practice-20211207/" class="article-date">
  <time class="dt-published" datetime="2021-12-08T03:31:20.000Z" itemprop="datePublished">2021-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/08/Leetcode-daily-practice-20211207/">Leetcode-daily-practice-20211207</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h5><p>这题我用了累乘的方式，时间复杂度O(n)。但其实有更快的思路。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">快速幂</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(log<del>2</del>n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>注意这里的b要为long类型，原因是，int类型的<code>-2147483648</code>的相反数仍为<code>-2147483648</code>，这是int类型溢出导致的。</p>
<h5 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h5><p>这题推导数学公式是最简单的方法，结论是，尽可能的剪出长度为3的段，这样乘积最大。这时可用贪心算法。</p>
<ul>
<li>贪心</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res = res * <span class="number">3</span> % mod;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res * n % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里最后应该返回<code>return (int)(res * n % mod);</code> ，而<code>return (int)res * n % mod;</code>是不同的结果。</p>
<p>当n比较小时，还可以使用动态规划。</p>
<ul>
<li>动态规划</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max_value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                max_value = Math.max(max_value, dp[j] * dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h5><p>这题我本来认为，所有的运动范围都在左上角，理所当然的想用累加的方式。但实际上，除了左上角的区域还有另外的区域。思路是从每一个连通的位置，思考右方向和下方向的位置是否可以到达。为了避免重复探索，需要m*n的布尔数组来指示是否已经探索过了。最后把符合条件的位置数目加起来。可以有三种实现：</p>
<ul>
<li>广度优先算法(使用队列)</li>
<li>递推</li>
<li>递归</li>
</ul>
<p>时间复杂度均为O(m<em>n)，空间复杂度均为O(m</em>n)</p>
<h5 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h5><p>这是矩阵搜索问题，可以使用<code>深度优先搜索DFS + 剪枝</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] words, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == board.length || i &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != words[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> dfs(board, words, i+<span class="number">1</span>, j, k+<span class="number">1</span>) || dfs(board, words, i, j+<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, words, i-<span class="number">1</span>, j, k+<span class="number">1</span>) || dfs(board, words, i, j-<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>时间复杂度：O(3^K^MN)</li>
<li>空间复杂度：O(K)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/08/Leetcode-daily-practice-20211207/" data-id="cl2umtqhr000c1tswcg1zeio2" data-title="Leetcode-daily-practice-20211207" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-daily-practice-20211206" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/06/Leetcode-daily-practice-20211206/" class="article-date">
  <time class="dt-published" datetime="2021-12-06T14:05:33.000Z" itemprop="datePublished">2021-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/06/Leetcode-daily-practice-20211206/">Leetcode-daily-practice-20211206</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h5><p>我首先从左上角出发，考虑右侧和下方的数字，如果小于target就推入队列，循环出列，直到找到target，或者没有找到target返回false。其中还用了m*n大小的布尔数组，来标记某数字是否检查过。但其实有更好的思路：从数组的右上角看是二分查找，元素小于target向下找，元素大于target向左找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[x][y] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;m &amp;&amp; y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                y --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &lt; target)&#123;</span><br><span class="line">                x ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h5 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h5><p>关于树的算法一般来说有递归和迭代两种方法。递归思路清晰，但需要使用递归栈；迭代需要使用栈或队列。</p>
<ol>
<li><p>递归</p>
<p>首先使用map存储中序遍历，key为元素，value为index，这样方便查询父节点的位置。</p>
<p>前序遍历的形式为<code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code></p>
<p>中序遍历的形式为<code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p>
<p>从前序遍历得到父节点的值，根据值在map中找到父节点的下标，据此下标计算左子树的节点个数，右子树的节点个数。然后递归建立左右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; all_treenode_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) all_treenode_map.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> buildMyTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildMyTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> pre_left, <span class="type">int</span> pre_right, <span class="type">int</span> in_left, <span class="type">int</span> in_right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_left &gt; pre_right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">root_value</span> <span class="operator">=</span> preorder[pre_left];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root_value);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">root_index_in_inorder</span> <span class="operator">=</span> all_treenode_map.get(root_value);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left_length</span> <span class="operator">=</span> root_index_in_inorder - in_left;</span><br><span class="line">        root.left = buildMyTree(preorder, inorder, pre_left+<span class="number">1</span>, pre_left+left_length, in_left, root_index_in_inorder-<span class="number">1</span>);</span><br><span class="line">        root.right = buildMyTree(preorder, inorder, pre_left+left_length+<span class="number">1</span>, pre_right, root_index_in_inorder+<span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li><p>迭代不容易理解，这里借鉴了官方题解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="literal">null</span> || preorder.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">in_index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;preorder.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 前序遍历中父节点的下一位（左子树不为空，是左子树的val，左子树为空，是右子树的val）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre_val</span> <span class="operator">=</span> preorder[i];</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="comment">// 中序遍历时没到父节点时，都是左子树的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.val != inorder[in_index])&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre_val);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            <span class="comment">// 中序遍历到了父节点，这时候建右子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到父节点</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[in_index])&#123;</span><br><span class="line">                    <span class="comment">// 倒出父节点（已经建好了左子树）</span></span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    in_index ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 建立右子树</span></span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre_val);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/06/Leetcode-daily-practice-20211206/" data-id="cl2umtqhr00081tsw7wk7942g" data-title="Leetcode-daily-practice-20211206" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-weekly-contest-270" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/05/Leetcode-weekly-contest-270/" class="article-date">
  <time class="dt-published" datetime="2021-12-05T10:05:57.000Z" itemprop="datePublished">2021-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/05/Leetcode-weekly-contest-270/">Leetcode-weekly-contest-270</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>Score</th>
<th>Finish Time</th>
<th>Q1(3)</th>
<th>Q2(4)</th>
<th>Q3(5)</th>
<th>Q4(6)</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>Null</td>
<td>Null</td>
<td>0:19:33</td>
<td>30:00</td>
<td>Null</td>
</tr>
</tbody></table>
<p>这周的题目特别不对味儿，可能这就是真实的周赛，也可能我只是周赛新手。</p>
<h5 id="5942-简单-找出-3-位偶数"><a href="#5942-简单-找出-3-位偶数" class="headerlink" title="5942(简单)找出 3 位偶数"></a>5942(简单)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/finding-3-digit-even-numbers/">找出 3 位偶数</a></h5><p>这题找出3位偶数有三个规则，而且还要满足<code>全部</code>和<code>互不相同</code>，最后按照<code>递增顺序</code>返回，很容易造成思路的混乱，最简单的方法是排除不满足规则的数，最后去重，排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findEvenNumbers(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> digits.length;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; j != k &amp;&amp; i != k &amp;&amp; digits[i] != <span class="number">0</span> &amp;&amp; digits[k]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                        set.add(digits[i]*<span class="number">100</span> + digits[j]*<span class="number">10</span> + digits[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> temp : set)&#123;</span><br><span class="line">            result[index++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK7之后，Array.sort()采用Timesrot排序算法，最坏时间复杂度为O(n*logn)，最坏空间复杂度是O(n&#x2F;2)</p>
<ul>
<li>时间复杂度O(N^3)</li>
<li>空间复杂度（最坏O(n&#x2F;2)）</li>
</ul>
<h5 id="5943-中等-删除链表的中间节点"><a href="#5943-中等-删除链表的中间节点" class="headerlink" title="5943(中等)删除链表的中间节点"></a>5943(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/">删除链表的中间节点</a></h5><p>这是典型的快慢指针题目。唯一要注意的是，中间节点是⌊n&#x2F;2⌋（<code>⌊x⌋</code>表示≤x的最大整数），这会导致快指针到最后位置时，慢指针正好是要删除的节点，所以要记录慢指针的前节点，方便删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteMiddle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h5 id="5944-中等-从二叉树一个节点到另一个节点每一步的方向"><a href="#5944-中等-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="5944(中等)从二叉树一个节点到另一个节点每一步的方向"></a>5944(中等)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/">从二叉树一个节点到另一个节点每一步的方向</a></h5><p>首先是寻找两个节点的最小公共祖先，参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">LC.236(中等)二叉树的最近公共祖先</a>，然后求youngest_root到dest的路径，youngest_root到start的深度，这代表U的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDirections</span><span class="params">(TreeNode root, <span class="type">int</span> startValue, <span class="type">int</span> destValue)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">young_root</span> <span class="operator">=</span> dfs(root, startValue, destValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加start到young_root的路径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> findStart(young_root, startValue);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            res.append(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加root到young_root的路径</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        findDest(young_root, destValue, sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最近的公共祖先young_root</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> startValue, <span class="type">int</span> destValue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == startValue || root.val == destValue)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> dfs(root.left, startValue, destValue);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> dfs(root.right, startValue, destValue);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找start到young_root有几个U</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findStart</span><span class="params">(TreeNode root, <span class="type">int</span> srcValue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == srcValue)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(findStart(root.left, srcValue), findStart(root.right, srcValue)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找young_root到dest的路径</span></span><br><span class="line">    <span class="comment">//sb.deleteCharAt()表示，如果没有找到左子树或右子树没有找到dest，就删除刚刚添加的&#x27;L&#x27;或&#x27;R&#x27;，还原路径。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findDest</span><span class="params">(TreeNode root, <span class="type">int</span> destValue, StringBuilder sb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == destValue)&#123;</span><br><span class="line">            res.append(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">            findDest(root.right, destValue, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            findDest(root.left, destValue, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：递归栈至多O(n)</li>
</ul>
<h5 id="5932-困难-合法重新排列数对"><a href="#5932-困难-合法重新排列数对" class="headerlink" title="5932(困难)合法重新排列数对"></a>5932(困难)<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-arrangement-of-pairs/">合法重新排列数对</a></h5><p>找到一个<code>出度（从该点出发的边的数量）</code>比 <code>入度（进入该点的边的数量）</code>大1的点作为起点。如果没找到这样的一个点，那么任何一个点都可以作为起点，这时所有点的<code>入度 = 出度</code>。做法是，从起点出发，遍历任意边，然后把边删除。如果当前点没有任何边连出，才在结果中加入该点（排除环）。递归进行这个过程，得到 “一笔画” 路径的 逆序。最后把路径翻转即可得到最终结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存放最后遍历的顺序</span></span><br><span class="line">    LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放所有元素的入度元素</span></span><br><span class="line">    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放所有元素的入度</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] validArrangement(<span class="type">int</span>[][] pairs) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] pair : pairs)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> pair[<span class="number">0</span>], in = pair[<span class="number">1</span>];</span><br><span class="line">            inDegree.put(in, inDegree.getOrDefault(in, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            LinkedList&lt;Integer&gt; list = map.getOrDefault(out, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">            list.add(in);</span><br><span class="line">            map.put(out, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> pairs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            LinkedList&lt;Integer&gt; outList = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">inValue</span> <span class="operator">=</span> inDegree.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(inValue + <span class="number">1</span> == outList.size())&#123;</span><br><span class="line">                start = key;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(start);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pairs.length;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>] = result.pollLast();</span><br><span class="line">            ans[i][<span class="number">1</span>] = result.peekLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = map.get(start);</span><br><span class="line">        <span class="keyword">while</span>(list != <span class="literal">null</span> &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> list.pollLast();</span><br><span class="line">            dfs(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(pairs.length)</p>
</li>
<li><p>空间复杂度：O(pairs.length)</p>
<p>注意题目中排除了自循环和重复循环的用例，否则这个算法不可行。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/05/Leetcode-weekly-contest-270/" data-id="cl2umtqht000h1tsw8xsu0oi3" data-title="Leetcode-weekly-contest-270" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode-weekly-contest-269" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/29/Leetcode-weekly-contest-269/" class="article-date">
  <time class="dt-published" datetime="2021-11-29T02:41:05.000Z" itemprop="datePublished">2021-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/29/Leetcode-weekly-contest-269/">Leetcode-weekly-contest-269</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>Score</th>
<th>Finish Time</th>
<th>Q1(3)</th>
<th>Q2(4)</th>
<th>Q3(5)</th>
<th>Q4(6)</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>Null</td>
<td>5:00</td>
<td>Null</td>
<td>30:00</td>
<td>Null</td>
</tr>
</tbody></table>
<h5 id="5938-简单-找出数组排序后的目标下表"><a href="#5938-简单-找出数组排序后的目标下表" class="headerlink" title="5938(简单) 找出数组排序后的目标下表"></a>5938(简单) 找出数组排序后的目标下表</h5><p>​	<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/">https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/</a></p>
<h5 id="5939-中等-半径为-k-的子数组平均值"><a href="#5939-中等-半径为-k-的子数组平均值" class="headerlink" title="5939(中等) 半径为 k 的子数组平均值"></a>5939(中等) 半径为 k 的子数组平均值</h5><p>​	<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-radius-subarray-averages/">https://leetcode-cn.com/problems/k-radius-subarray-averages/</a></p>
<p>​	这题我的思路不错，下标自增的时候，k半径范围内的数一增一减。但实际上花了很多时间，主要是写了很多if分支，在确定每个分支的功能时花了很多时间。最后还吃了三次罚时，第一次是因为忘记删除debug信息，第二次未通过但没看错误信息，第三次想不到错误的点故意吃的罚时。未通过的用例k为40000，范围很大，就没有再调试了，最后评论区找到了更好的思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getAverages(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>*k)&#123;</span><br><span class="line">                res[i - k] = (<span class="type">int</span>)(sum / (<span class="number">2</span> * k + <span class="number">1</span>));</span><br><span class="line">                sum -= nums[i - <span class="number">2</span>*k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2091-中等-从数组中移除最大值和最小值"><a href="#2091-中等-从数组中移除最大值和最小值" class="headerlink" title="2091(中等) 从数组中移除最大值和最小值"></a>2091(中等) 从数组中移除最大值和最小值</h5><p>​	<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/">https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/</a></p>
<h5 id="5941-困难-找出知晓秘密的所有专家"><a href="#5941-困难-找出知晓秘密的所有专家" class="headerlink" title="5941(困难) 找出知晓秘密的所有专家"></a>5941(困难) 找出知晓秘密的所有专家</h5><p>​	<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-people-with-secret/">https://leetcode-cn.com/problems/find-all-people-with-secret/</a></p>
<p>这题考察图的遍历</p>
<p>Dijkstra算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAllPeople</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> firstPerson)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] meeting : meetings) &#123;</span><br><span class="line">            graph[meeting[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;meeting[<span class="number">1</span>], meeting[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[meeting[<span class="number">1</span>]].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;meeting[<span class="number">0</span>], meeting[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按时间排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; (o1[<span class="number">1</span>] - o2[<span class="number">1</span>]));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;firstPerson, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> cur[<span class="number">0</span>], t = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            res.add(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] next : graph[cur[<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> next[<span class="number">0</span>], time = next[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (vis[p] || time &lt; t) <span class="keyword">continue</span>;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序+查并集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并查集数组，记录每个元素的祖先节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找每个元素的祖先，（路径压缩，并查集模板）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAllPeople</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> firstPerson)</span> &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 祖先数组初始化，将每个元素的祖先标记为自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++ i) p[i] = i;</span><br><span class="line">        <span class="comment">// 合并0号专家与firstPerson</span></span><br><span class="line">        p[firstPerson] = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="type">int</span>[]&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构造以时刻为key，会议列表为value的Map，TreeMap将自动按照key升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] m : meetings) &#123;</span><br><span class="line">            <span class="comment">// m[2]为会议时刻，每个时刻对应多场会议</span></span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list = map.getOrDefault(m[<span class="number">2</span>], <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(m);</span><br><span class="line">            map.put(m[<span class="number">2</span>], list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于每个时刻，遍历两次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 第一轮遍历，合并集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] l : map.get(x)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l[<span class="number">0</span>], b = l[<span class="number">1</span>];                </span><br><span class="line">                <span class="keyword">if</span> (p[find(a)] == <span class="number">0</span> || p[find(b)] == <span class="number">0</span>) &#123; p[find(a)] = <span class="number">0</span>; p[find(b)] = <span class="number">0</span>; &#125;</span><br><span class="line">                p[find(b)] = p[find(a)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二轮遍历，分场景讨论</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] l : map.get(x)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l[<span class="number">0</span>], b = l[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 场景一：两位专家在前面的会议均不知道秘密，后面遍历中其中一位专家知道了秘密，瞬时共享，两人都将知道秘密</span></span><br><span class="line">                <span class="keyword">if</span> (p[find(a)] == <span class="number">0</span> || p[find(b)] == <span class="number">0</span>) &#123; p[find(a)] = <span class="number">0</span>; p[find(b)] = <span class="number">0</span>; &#125;</span><br><span class="line">                <span class="comment">// 场景二：两位专家在该时刻始终都不知道秘密，将合并的集合分离开，防止后面时刻有一个专家知道秘密，将秘密分享给另一个专家</span></span><br><span class="line">                <span class="keyword">else</span> &#123; p[a] = a; p[b] = b; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 祖先为0的元素即为知道秘密的专家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[find(i)] == <span class="number">0</span>) ans.add(i);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/29/Leetcode-weekly-contest-269/" data-id="cl2umtqhs000g1tsw8h6n2zg8" data-title="Leetcode-weekly-contest-269" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-阿里云部署SpringBoot应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-11-29T00:54:11.000Z" itemprop="datePublished">2021-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/">阿里云部署SpringBoot应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我买了阿里云的轻量服务器，双十一的折扣不要太划算，43块钱租赁一整年。服务器系统设置成CentOS8，用来验证Spring Boot应用的部署环节。</p>
<p>部署的流程很简单：本地成功运行SpringBoot应用 -&gt; 打成jar包 -&gt; 配置CentOS环境 -&gt; 部署jar包到服务器，可实际上，过程中走了很多弯路，却也有趣。从下午6点一直到1点半，我十分投入，甚至晚饭也忘了。本来打算立即写下这件事的，迫于太晚了，只好推到了早上。</p>
<p>  本地运行SpringBoot</p>
<p>这个应用克隆自<code>https://github.com/gabrieldim/Email-Sender-Spring-Boot.git</code>，实现了通过url发送邮件。需要配置发送人的邮箱信息，这里我用了QQ邮箱做测试。</p>
<p>注意要开启邮箱的第三方服务</p>


<p>  打成jar包</p>
<p>这里我使用了IDEA的打包工具，但是IDEA给我留了陷阱。</p>


<p>这里的MANIFEST.MF文件应该放在根目录下，也即删除<code>\src\main\java</code>，然后顺着流程走下来，jar包放在<code>.out\artifacts\email_sender-jar</code></p>
<p>  配置CentOS</p>
<p>主要有两部分，安装jdk11和Tomcat。</p>
<p>安装jdk11走了很多弯路，最开始我用wget安装，但是在Oracle官网下载的tar.gz文件总是HTML类型的，导致解压出错。即使在wget命令中添加同意协议的cookie信息，依然如此。最后我换了思路，我先下载到windows本地，然后上传到LINUX服务器。</p>
<p>上传的操作利用了PPUTY工具。其实有很多方法的，但是之前连接AWS虚机的时候安装了PUTTY，所以直接拿来用最方便啦。PPUTY的命令是<code>pscp 本机压缩文件 Linux用户@Linux公用IP:Linux服务器目录</code>。</p>
<p>JDK安装包上传到服务器，首先用<code>tar -zxvf jdk-11.0.13-linux-x64.tar.gz</code>解压到<code>/usr/local/java</code>，这是我放置安装包的地方。然后在<code>vim /etc/profile</code>配置环境变量，在文件末尾添加&#96;&#96;</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## JAVA</span><br><span class="line">JAVA_HOME=/usr/local/jdk-<span class="number">11.0</span>.<span class="number">13</span></span><br><span class="line">JRE_HOME=/usr/local/jdk-<span class="number">11.0</span>.<span class="number">13</span></span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<p>最后要<code>source /etc/profile</code>刷新当前shell环境。<code>java -version</code>看到Java信息就算成功。</p>
<p>安装Tomcat最艰难，下载和安装过程和jdk大同小异，只是安装目录是<code>/usr/local/tomcat/apache-tomcat-10.0.13</code>，执行bin目录下启动命令<code>./startup.sh</code>，但是tomcat的启动日志<code>tail -f ../logs/catalina.out</code>一直报错，无法找到<code>./jdk-11.0.13/bin/jre/bin/java</code>无法找到路径，cd到相应目录发现没有jre目录，原来是Oracle搞得鬼，JDK11及以后，不单独提供JRE模块，但是用户可以自行创建JRE，命令则是在jdk的bin目录下执行<code>jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>。之后重启Tomcat还是有错误，把JRE配置为和JDK同一目录便解决啦。</p>
<p>这时Tomcat已经安装好啦。我用windows的浏览器试着连接服务器的8080端口，但一直超时。这部分查了很久，直到看到有篇文章无心插柳提到了防火墙，我想起我忘了开放服务器的8080端口了Orz。</p>
<p>  部署应用</p>
<p>第一次没有成功，解决了上文IDEA留的陷阱就可以啦。</p>
<p>jar包目录下执行<code>java -jar email-sender.jar</code>可以看到Spring的信息。成功！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/" data-id="cl2umtqhu000m1tswhz8u135i" data-title="阿里云部署SpringBoot应用" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aliyun/" rel="tag">aliyun</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/deploy/" rel="tag">deploy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PTE-Score" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/27/PTE-Score/" class="article-date">
  <time class="dt-published" datetime="2021-11-27T01:45:19.000Z" itemprop="datePublished">2021-11-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/certification/">certification</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/27/PTE-Score/">PTE-Score</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>2021.09.18</p>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/27/PTE-Score/" data-id="cl2umtqht000k1tswagud6dsl" data-title="PTE-Score" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/certification/" rel="tag">certification</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pte/" rel="tag">pte</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AWS-SAP-Certification" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/AWS-SAP-Certification/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T14:46:00.000Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/certification/">certification</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/28/AWS-SAP-Certification/">AWS SAP Certification</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>2021.06.24</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/AWS-SAP-Certification/" data-id="cl2umtqhq00071tsw4fnddww9" data-title="AWS SAP Certification" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aws/" rel="tag">aws</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/certification/" rel="tag">certification</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/certification/">certification</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aliyun/" rel="tag">aliyun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aws/" rel="tag">aws</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/certification/" rel="tag">certification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deploy/" rel="tag">deploy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pte/" rel="tag">pte</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/aliyun/" style="font-size: 10px;">aliyun</a> <a href="/tags/aws/" style="font-size: 10px;">aws</a> <a href="/tags/certification/" style="font-size: 15px;">certification</a> <a href="/tags/deploy/" style="font-size: 10px;">deploy</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/pte/" style="font-size: 10px;">pte</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/09/Leetcode-daily-practice-20211209/">Leetcode-daily-practice-20211209</a>
          </li>
        
          <li>
            <a href="/2021/12/08/Leetcode-daily-practice-20211208/">Leetcode-daily-practice-20211208</a>
          </li>
        
          <li>
            <a href="/2021/12/08/Leetcode-daily-practice-20211207/">Leetcode-daily-practice-20211207</a>
          </li>
        
          <li>
            <a href="/2021/12/06/Leetcode-daily-practice-20211206/">Leetcode-daily-practice-20211206</a>
          </li>
        
          <li>
            <a href="/2021/12/05/Leetcode-weekly-contest-270/">Leetcode-weekly-contest-270</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 李嘉文<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>